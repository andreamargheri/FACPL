/**
 * generated by Xtext
 */
package it.unifi.xtext.facpl.validation;

import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.inject.Inject;
import it.unifi.xtext.facpl.facpl2.AbstractPolicyIncl;
import it.unifi.xtext.facpl.facpl2.Alg;
import it.unifi.xtext.facpl.facpl2.AlgLiteral;
import it.unifi.xtext.facpl.facpl2.AndExpression;
import it.unifi.xtext.facpl.facpl2.AttributeName;
import it.unifi.xtext.facpl.facpl2.AttributeReq;
import it.unifi.xtext.facpl.facpl2.DateLiteral;
import it.unifi.xtext.facpl.facpl2.DeclaredFunction;
import it.unifi.xtext.facpl.facpl2.Expression;
import it.unifi.xtext.facpl.facpl2.Facpl;
import it.unifi.xtext.facpl.facpl2.Facpl2Package;
import it.unifi.xtext.facpl.facpl2.FacplPolicy;
import it.unifi.xtext.facpl.facpl2.FulfillmentStrategy;
import it.unifi.xtext.facpl.facpl2.Function;
import it.unifi.xtext.facpl.facpl2.FunctionDeclaration;
import it.unifi.xtext.facpl.facpl2.Import;
import it.unifi.xtext.facpl.facpl2.MainFacpl;
import it.unifi.xtext.facpl.facpl2.NotExpression;
import it.unifi.xtext.facpl.facpl2.OrExpression;
import it.unifi.xtext.facpl.facpl2.PAF;
import it.unifi.xtext.facpl.facpl2.PDP;
import it.unifi.xtext.facpl.facpl2.PolicySet;
import it.unifi.xtext.facpl.facpl2.Request;
import it.unifi.xtext.facpl.facpl2.TimeLiteral;
import it.unifi.xtext.facpl.facpl2.TypeLiteral;
import it.unifi.xtext.facpl.facpl2.funID;
import it.unifi.xtext.facpl.validation.AbstractFacpl2Validator;
import it.unifi.xtext.facpl.validation.FacplType;
import it.unifi.xtext.facpl.validation.inference.FacplTypeInference;
import it.unifi.xtext.facpl.validation.inference.SubstitutionSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.scoping.IGlobalScopeProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class Facpl2Validator extends AbstractFacpl2Validator {
  public static class LoopException extends Exception {
    @Override
    public String getMessage() {
      return super.getMessage();
    }
  }
  
  @Inject
  private IGlobalScopeProvider gloablScope;
  
  /**
   * ###################################################
   * Check Name Requests
   * ###################################################
   */
  @Check
  public void checkNameRequest(final Request request) {
    Facpl a = this.getRoot(request);
    Boolean flag = Boolean.valueOf(false);
    EList<Request> _requests = a.getRequests();
    for (final Request el : _requests) {
      if ((el instanceof Request)) {
        String _name = el.getName();
        String _name_1 = request.getName();
        boolean _equals = _name.equals(_name_1);
        if (_equals) {
          if ((flag).booleanValue()) {
            String _name_2 = request.getName();
            String _plus = ("Duplicate request name \'" + _name_2);
            String _plus_1 = (_plus + "\'");
            this.error(_plus_1, 
              Facpl2Package.Literals.REQUEST__NAME);
            return;
          }
          flag = Boolean.valueOf(true);
        }
      }
    }
  }
  
  @Check
  public void checkGlobalNameRequest(final Request request) {
    Resource _eResource = request.eResource();
    IScope global = this.gloablScope.getScope(_eResource, Facpl2Package.Literals.MAIN_FACPL__REF_REQUEST, 
      new Predicate<IEObjectDescription>() {
        @Override
        public boolean apply(final IEObjectDescription input) {
          return true;
        }
      });
    Iterable<IEObjectDescription> _allElements = global.getAllElements();
    for (final IEObjectDescription eOb : _allElements) {
      QualifiedName _name = eOb.getName();
      String _string = _name.toString();
      String _name_1 = request.getName();
      boolean _equals = _string.equals(_name_1);
      if (_equals) {
        String _name_2 = request.getName();
        String _plus = ("Duplicate request name \'" + _name_2);
        String _plus_1 = (_plus + "\' with file imported");
        this.error(_plus_1, 
          Facpl2Package.Literals.REQUEST__NAME);
        return;
      }
    }
  }
  
  /**
   * ###################################################
   * Check Well-Formed Set Attributes in Requests
   * ###################################################
   */
  @Check
  public void checkAttributeRequestType(final AttributeReq a) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(a);
    tCheck.doSwitch(_root);
    FacplType t = tCheck.doSwitch(a);
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Type mismatch: all Set elements must be of the same type", 
        Facpl2Package.Literals.ATTRIBUTE_REQ__VALUE);
    } else {
      boolean _equals_1 = t.equals(FacplType.NAME);
      if (_equals_1) {
        this.error("Type mismatch: request attribute cannot be names", Facpl2Package.Literals.ATTRIBUTE_REQ__VALUE);
      }
    }
  }
  
  /**
   * #######################################################
   * Check in global scope for policySet name policy
   * #######################################################
   */
  @Check
  public void checkGlobalPolicy(final FacplPolicy policy) {
    Resource _eResource = policy.eResource();
    IScope global = this.gloablScope.getScope(_eResource, 
      Facpl2Package.Literals.ABSTRACT_POLICY_INCL__REF_POL, new Predicate<IEObjectDescription>() {
      @Override
      public boolean apply(final IEObjectDescription input) {
        return true;
      }
    });
    Iterable<IEObjectDescription> _allElements = global.getAllElements();
    for (final IEObjectDescription eOb : _allElements) {
      QualifiedName _name = eOb.getName();
      String _lastSegment = _name.getLastSegment();
      String _string = _lastSegment.toString();
      String _name_1 = policy.getName();
      boolean _equals = _string.equals(_name_1);
      if (_equals) {
        String _name_2 = policy.getName();
        String _plus = ("Duplicate policy name \'" + _name_2);
        String _plus_1 = (_plus + "\'");
        String _plus_2 = (_plus_1 + 
          ". A policy with the same name is defined in an imported file");
        this.error(_plus_2, 
          Facpl2Package.Literals.FACPL_POLICY__NAME);
        return;
      }
    }
  }
  
  /**
   * #############################################################
   * Check Policy Set / Rule Collisions in the local file
   * #############################################################
   */
  @Check
  public void checkLocalPolicy(final FacplPolicy policy) {
    String name_policy = policy.getName();
    Facpl root = this.getRoot(policy);
    int count = 0;
    EList<PolicySet> _policies = root.getPolicies();
    for (final FacplPolicy p : _policies) {
      {
        String _name = p.getName();
        boolean _equals = _name.equals(name_policy);
        if (_equals) {
          count++;
        }
        if ((p instanceof PolicySet)) {
          int _count = count;
          int _checkNamePolicySet = this.checkNamePolicySet(name_policy, ((PolicySet) p));
          count = (_count + _checkNamePolicySet);
        }
      }
    }
    MainFacpl _main = root.getMain();
    boolean _notEquals = (!Objects.equal(_main, null));
    if (_notEquals) {
      MainFacpl _main_1 = root.getMain();
      PAF _paf = _main_1.getPaf();
      boolean _notEquals_1 = (!Objects.equal(_paf, null));
      if (_notEquals_1) {
        MainFacpl _main_2 = root.getMain();
        PAF _paf_1 = _main_2.getPaf();
        PDP _pdp = _paf_1.getPdp();
        boolean _notEquals_2 = (!Objects.equal(_pdp, null));
        if (_notEquals_2) {
          MainFacpl _main_3 = root.getMain();
          PAF _paf_2 = _main_3.getPaf();
          PDP _pdp_1 = _paf_2.getPdp();
          EList<AbstractPolicyIncl> _polSet = _pdp_1.getPolSet();
          for (final AbstractPolicyIncl p_1 : _polSet) {
            FacplPolicy _newPolicy = p_1.getNewPolicy();
            boolean _notEquals_3 = (!Objects.equal(_newPolicy, null));
            if (_notEquals_3) {
              FacplPolicy _newPolicy_1 = p_1.getNewPolicy();
              String _name = _newPolicy_1.getName();
              boolean _equals = _name.equals(name_policy);
              if (_equals) {
                count++;
              }
              FacplPolicy _newPolicy_2 = p_1.getNewPolicy();
              if ((_newPolicy_2 instanceof PolicySet)) {
                int _count = count;
                FacplPolicy _newPolicy_3 = p_1.getNewPolicy();
                int _checkNamePolicySet = this.checkNamePolicySet(name_policy, ((PolicySet) _newPolicy_3));
                count = (_count + _checkNamePolicySet);
              }
            }
          }
        }
      }
    }
    if ((count > 1)) {
      String _name_1 = policy.getName();
      String _plus = ("Duplicate policy name \'" + _name_1);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, Facpl2Package.Literals.FACPL_POLICY__NAME);
    }
  }
  
  public int checkNamePolicySet(final String name, final PolicySet polSet) {
    int count = 0;
    EList<AbstractPolicyIncl> _policies = polSet.getPolicies();
    for (final AbstractPolicyIncl p : _policies) {
      FacplPolicy _newPolicy = p.getNewPolicy();
      boolean _notEquals = (!Objects.equal(_newPolicy, null));
      if (_notEquals) {
        FacplPolicy _newPolicy_1 = p.getNewPolicy();
        String _name = _newPolicy_1.getName();
        boolean _equals = _name.equals(name);
        if (_equals) {
          count++;
        }
        FacplPolicy _newPolicy_2 = p.getNewPolicy();
        if ((_newPolicy_2 instanceof PolicySet)) {
          int _count = count;
          FacplPolicy _newPolicy_3 = p.getNewPolicy();
          int _checkNamePolicySet = this.checkNamePolicySet(name, ((PolicySet) _newPolicy_3));
          count = (_count + _checkNamePolicySet);
        }
      }
    }
    return count;
  }
  
  /**
   * ###################################################
   * LOOP DEPENDECIES WITHIN POLICY SET
   * ###################################################
   */
  @Check
  public void checkLoopFree(final PolicySet pSet) {
    try {
      this.checkLoop(pSet, null);
    } catch (final Throwable _t) {
      if (_t instanceof Facpl2Validator.LoopException) {
        final Facpl2Validator.LoopException e = (Facpl2Validator.LoopException)_t;
        String _name = pSet.getName();
        String _plus = ("The Policy may generate an evaluation loop starting from " + _name);
        this.warning(_plus, 
          Facpl2Package.Literals.FACPL_POLICY__NAME);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public HashMap<String, ArrayList<String>> checkLoop(final PolicySet pSet, final HashMap<String, ArrayList<String>> dp) throws Facpl2Validator.LoopException {
    HashMap<String, ArrayList<String>> dp_graph = dp;
    ArrayList<String> sub_pols = new ArrayList<String>();
    ArrayList<EObject> eob_sub_pols = new ArrayList<EObject>();
    EList<AbstractPolicyIncl> _policies = pSet.getPolicies();
    for (final AbstractPolicyIncl p : _policies) {
      {
        FacplPolicy _newPolicy = p.getNewPolicy();
        boolean _notEquals = (!Objects.equal(_newPolicy, null));
        if (_notEquals) {
          FacplPolicy _newPolicy_1 = p.getNewPolicy();
          String _name = _newPolicy_1.getName();
          sub_pols.add(_name);
          FacplPolicy _newPolicy_2 = p.getNewPolicy();
          eob_sub_pols.add(_newPolicy_2);
        }
        PolicySet _refPol = p.getRefPol();
        boolean _notEquals_1 = (!Objects.equal(_refPol, null));
        if (_notEquals_1) {
          PolicySet _refPol_1 = p.getRefPol();
          String _name_1 = _refPol_1.getName();
          sub_pols.add(_name_1);
          PolicySet _refPol_2 = p.getRefPol();
          eob_sub_pols.add(_refPol_2);
        }
      }
    }
    boolean _equals = Objects.equal(dp_graph, null);
    if (_equals) {
      HashMap<String, ArrayList<String>> _hashMap = new HashMap<String, ArrayList<String>>();
      dp_graph = _hashMap;
    }
    String _name = pSet.getName();
    dp_graph.put(_name, sub_pols);
    for (final EObject r : eob_sub_pols) {
      if ((r instanceof PolicySet)) {
        Boolean f = Boolean.valueOf(false);
        boolean _equals_1 = Objects.equal(dp_graph, null);
        if (_equals_1) {
          f = Boolean.valueOf(true);
        } else {
          String _name_1 = ((PolicySet) r).getName();
          boolean _containsKey = dp_graph.containsKey(_name_1);
          boolean _not = (!_containsKey);
          if (_not) {
            f = Boolean.valueOf(true);
          }
        }
        if ((f).booleanValue()) {
          HashMap<String, ArrayList<String>> sub_pol_dependencies = this.checkLoop(((PolicySet) r), dp_graph);
          Set<String> _keySet = sub_pol_dependencies.keySet();
          for (final String polName : _keySet) {
            ArrayList<String> _get = sub_pol_dependencies.get(polName);
            dp_graph.put(polName, _get);
          }
        }
        boolean _hasLoop = this.hasLoop(dp_graph);
        if (_hasLoop) {
          throw new Facpl2Validator.LoopException();
        }
      }
    }
    return dp_graph;
  }
  
  public boolean hasLoop(final HashMap<String, ArrayList<String>> dp_graph) {
    HashMap<String, Boolean> visited = new HashMap<String, Boolean>();
    Set<String> _keySet = dp_graph.keySet();
    for (final String el : _keySet) {
      visited.put(el, Boolean.valueOf(false));
    }
    Set<String> _keySet_1 = dp_graph.keySet();
    for (final String el_1 : _keySet_1) {
      {
        visited.put(el_1, Boolean.valueOf(true));
        boolean _hasLoopUtil = this.hasLoopUtil(dp_graph, el_1, visited);
        if (_hasLoopUtil) {
          return true;
        }
      }
    }
    return false;
  }
  
  public boolean hasLoopUtil(final HashMap<String, ArrayList<String>> dp_graph, final String el, final HashMap<String, Boolean> visited) {
    ArrayList<String> _get = dp_graph.get(el);
    for (final String sub_el : _get) {
      Boolean _get_1 = visited.get(sub_el);
      if ((_get_1).booleanValue()) {
        return true;
      } else {
        visited.put(sub_el, Boolean.valueOf(true));
        this.hasLoopUtil(dp_graph, sub_el, visited);
      }
    }
    return false;
  }
  
  /**
   * Utility
   */
  public Facpl getRoot(final EObject policy) {
    EObject eObject = policy;
    while ((!(eObject.eContainer() instanceof Facpl))) {
      EObject _eContainer = eObject.eContainer();
      eObject = _eContainer;
    }
    EObject _eContainer = eObject.eContainer();
    return ((Facpl) _eContainer);
  }
  
  /**
   * ###################################################
   * CHECK IMPORT URI and MAIN Attributes
   * ###################################################
   */
  @Inject
  private XtextResourceSet set;
  
  @Check
  public void checkImportUriIsNotEmpty(final Import imports) {
    if (((!Objects.equal(imports.getImportURI(), null)) && (imports.getImportURI().trim().length() == 0))) {
      this.error("Empty importURI string", null);
    }
  }
  
  @Check
  public void checkMain(final MainFacpl p) {
    Facpl root = this.getRoot(p);
    StringBuffer importFile = new StringBuffer();
    int i = 1;
    Resource _eResource = p.eResource();
    URI _uRI = _eResource.getURI();
    List<String> _segmentsList = _uRI.segmentsList();
    for (final String s : _segmentsList) {
      {
        if ((i != 1)) {
          Resource _eResource_1 = p.eResource();
          URI _uRI_1 = _eResource_1.getURI();
          List<String> _segmentsList_1 = _uRI_1.segmentsList();
          int _size = _segmentsList_1.size();
          boolean _notEquals = (i != _size);
          if (_notEquals) {
            importFile.append((s + "/"));
          }
        }
        i = (i + 1);
      }
    }
    EList<Import> _importEl = root.getImportEl();
    for (final Import el : _importEl) {
      {
        Resource res = null;
        Boolean flag = Boolean.valueOf(false);
        try {
          String _string = importFile.toString();
          String _importURI = el.getImportURI();
          String _plus = (_string + _importURI);
          URI uri = URI.createPlatformResourceURI(_plus, true);
          try {
            Resource _resource = this.set.getResource(uri, true);
            res = _resource;
            flag = Boolean.valueOf(true);
          } catch (final Throwable _t) {
            if (_t instanceof Exception) {
              final Exception f = (Exception)_t;
              this.set.createResource(uri);
              Resource _resource_1 = this.set.getResource(uri, true);
              res = _resource_1;
              flag = Boolean.valueOf(true);
            } else {
              throw Exceptions.sneakyThrow(_t);
            }
          }
        } catch (final Throwable _t_1) {
          if (_t_1 instanceof Exception) {
            final Exception e = (Exception)_t_1;
            return;
          } else {
            throw Exceptions.sneakyThrow(_t_1);
          }
        }
        if ((flag).booleanValue()) {
          EList<EObject> _contents = res.getContents();
          for (final EObject ob : _contents) {
            if ((ob instanceof Facpl)) {
              MainFacpl _main = ((Facpl) ob).getMain();
              boolean _notEquals = (!Objects.equal(_main, null));
              if (_notEquals) {
                String _importURI_1 = el.getImportURI();
                String _plus_1 = ("These Main Attributes override Main of " + _importURI_1);
                String _plus_2 = (_plus_1 + " file");
                this.warning(_plus_2, null);
                return;
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Check date format yyyy/MM/dd
   */
  @Check
  public void checkDate(final DateLiteral date) {
    String sdate = date.getValue();
    boolean _checkDate = this.checkDate(sdate);
    boolean _not = (!_checkDate);
    if (_not) {
      this.error("Error date value. Must be yyyy/MM/dd", Facpl2Package.Literals.DATE_LITERAL__VALUE);
    }
  }
  
  /**
   * Check time format HH:mm:ss
   */
  @Check
  public void checkTime(final TimeLiteral time) {
    String stime = time.getValue();
    boolean _checkTime = this.checkTime(stime);
    boolean _not = (!_checkTime);
    if (_not) {
      this.error("Error time value. Must be HH:mm:ss", Facpl2Package.Literals.TIME_LITERAL__VALUE);
    }
  }
  
  public boolean checkTime(final String sdate) {
    final int h_sep = sdate.indexOf(":");
    final int m_sep = sdate.indexOf(":", 5);
    if ((h_sep == (-1))) {
      return false;
    } else {
      if ((m_sep == (-1))) {
        return false;
      }
    }
    String h = sdate.substring(0, 2);
    String m = sdate.substring(3, 5);
    String s = sdate.substring(6, 8);
    int _parseInt = Integer.parseInt(h);
    boolean _lessThan = (_parseInt < 24);
    if (_lessThan) {
      int _parseInt_1 = Integer.parseInt(m);
      boolean _lessThan_1 = (_parseInt_1 < 60);
      if (_lessThan_1) {
        int _parseInt_2 = Integer.parseInt(s);
        boolean _lessThan_2 = (_parseInt_2 < 60);
        if (_lessThan_2) {
          return true;
        }
      }
    }
    return false;
  }
  
  public boolean checkDate(final String sdate) {
    final int y_sep = sdate.indexOf("/");
    final int m_sep = sdate.indexOf("/", 5);
    if ((y_sep == (-1))) {
      return false;
    } else {
      if ((m_sep == (-1))) {
        return false;
      }
    }
    String m = sdate.substring((y_sep + 1), (y_sep + (m_sep - y_sep)));
    String d = sdate.substring((m_sep + 1));
    int _parseInt = Integer.parseInt(m);
    boolean _lessEqualsThan = (_parseInt <= 12);
    if (_lessEqualsThan) {
      int _parseInt_1 = Integer.parseInt(d);
      boolean _lessEqualsThan_1 = (_parseInt_1 <= 31);
      if (_lessEqualsThan_1) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Error for the multi-valued attributes
   */
  @Check
  public void checkAttributeRequestName(final AttributeReq a) {
    EObject _eContainer = a.eContainer();
    Request r = ((Request) _eContainer);
    Boolean flag = Boolean.valueOf(false);
    EList<AttributeReq> _attributes = r.getAttributes();
    for (final AttributeReq atr : _attributes) {
      if ((atr.getName().getCategory().equals(a.getName().getCategory()) && atr.getName().getId().equals(a.getName().getId()))) {
        if ((flag).booleanValue()) {
          this.error("Attributes with same names must be declared as Set of values", 
            Facpl2Package.Literals.ATTRIBUTE_REQ__NAME);
          return;
        } else {
          flag = Boolean.valueOf(true);
        }
      }
    }
  }
  
  /**
   * Warning for fulfilment strategies for consensus algorithm
   */
  @Check
  public void checkAlgGreedy(final Alg alg) {
    FulfillmentStrategy _fStrategy = alg.getFStrategy();
    boolean _notEquals = (!Objects.equal(_fStrategy, null));
    if (_notEquals) {
      FulfillmentStrategy _fStrategy_1 = alg.getFStrategy();
      boolean _equals = _fStrategy_1.equals(FulfillmentStrategy.GREEDY);
      if (_equals) {
        if (((alg.getIdAlg().equals(AlgLiteral.FIRST) || alg.getIdAlg().equals(AlgLiteral.ONLY_ONE)) || 
          alg.getIdAlg().equals(
            AlgLiteral.WEAK_CONS))) {
          this.warning(
            "Algorithms first-applicable, only-one-applicable and weak-consensus have the same implementation with or without greedy option", 
            Facpl2Package.Literals.ALG__FSTRATEGY);
        }
      }
    }
  }
  
  /**
   * Check uniqueness of function names
   */
  @Check
  public void checkNameDeclFun(final FunctionDeclaration f) {
    final Facpl root = this.getRoot(f);
    int i = 0;
    EList<FunctionDeclaration> _declarations = root.getDeclarations();
    for (final FunctionDeclaration dec : _declarations) {
      String _name = dec.getName();
      String _name_1 = f.getName();
      boolean _equals = Objects.equal(_name, _name_1);
      if (_equals) {
        i++;
      }
    }
    if ((i > 1)) {
      String _name_2 = f.getName();
      String _plus = ("Duplicate function name " + _name_2);
      this.error(_plus, 
        Facpl2Package.Literals.FUNCTION_DECLARATION__NAME);
    }
  }
  
  /**
   * Check for function invocation
   */
  @Check
  public void checkInvokDeclFun(final DeclaredFunction f) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    final Facpl root = this.getRoot(f);
    tCheck.doSwitch(root);
    EList<FunctionDeclaration> _declarations = root.getDeclarations();
    for (final FunctionDeclaration dec : _declarations) {
      String _name = dec.getName();
      FunctionDeclaration _functionId = f.getFunctionId();
      String _name_1 = _functionId.getName();
      boolean _equals = _name.equals(_name_1);
      if (_equals) {
        EList<TypeLiteral> _args = dec.getArgs();
        int _size = _args.size();
        EList<Expression> _args_1 = f.getArgs();
        int _size_1 = _args_1.size();
        boolean _notEquals = (_size != _size_1);
        if (_notEquals) {
          this.error(
            "Invalid number of arguments", 
            Facpl2Package.Literals.DECLARED_FUNCTION__FUNCTION_ID);
        }
        boolean flag = false;
        String decl_fun_T = "";
        String current_T = "";
        for (int i = 0; (i < f.getArgs().size()); i++) {
          {
            EList<Expression> _args_2 = f.getArgs();
            Expression _get = _args_2.get(i);
            FacplType type = tCheck.doSwitch(_get);
            boolean _equals_1 = type.equals(FacplType.NAME);
            if (_equals_1) {
              SubstitutionSet _typeAssignments = tCheck.getTypeAssignments();
              EList<Expression> _args_3 = f.getArgs();
              Expression _get_1 = _args_3.get(i);
              FacplType _bound = _typeAssignments.getBound(((AttributeName) _get_1));
              type = _bound;
              boolean _equals_2 = Objects.equal(type, null);
              if (_equals_2) {
              } else {
                boolean _equals_3 = type.equals(FacplType.ERR);
                if (_equals_3) {
                  EList<Expression> _args_4 = f.getArgs();
                  Expression _get_2 = _args_4.get(i);
                  String _category = ((AttributeName) _get_2).getCategory();
                  String _plus = ("Type mismatch: type for argument \'" + _category);
                  String _plus_1 = (_plus + "/");
                  EList<Expression> _args_5 = f.getArgs();
                  Expression _get_3 = _args_5.get(i);
                  String _id = ((AttributeName) _get_3).getId();
                  String _plus_2 = (_plus_1 + _id);
                  String _plus_3 = (_plus_2 + "\' cannot be inferred");
                  this.error(_plus_3, 
                    Facpl2Package.Literals.DECLARED_FUNCTION__FUNCTION_ID);
                  return;
                }
                EList<TypeLiteral> _args_6 = dec.getArgs();
                TypeLiteral _get_4 = _args_6.get(i);
                boolean _equalType = FacplType.equalType(type, _get_4);
                boolean _not = (!_equalType);
                if (_not) {
                  flag = true;
                }
              }
            } else {
              EList<TypeLiteral> _args_7 = dec.getArgs();
              TypeLiteral _get_5 = _args_7.get(i);
              boolean _equalType_1 = FacplType.equalType(type, _get_5);
              boolean _not_1 = (!_equalType_1);
              if (_not_1) {
                flag = true;
              }
            }
            if ((i > 0)) {
              EList<TypeLiteral> _args_8 = dec.getArgs();
              TypeLiteral _get_6 = _args_8.get(i);
              String _string = _get_6.toString();
              String _plus_4 = ((decl_fun_T + ",") + _string);
              decl_fun_T = _plus_4;
              boolean _equals_4 = Objects.equal(type, null);
              if (_equals_4) {
                current_T = (current_T + ", ?");
              } else {
                String _string_1 = type.toString();
                String _plus_5 = ((current_T + ",") + _string_1);
                current_T = _plus_5;
              }
            } else {
              EList<TypeLiteral> _args_9 = dec.getArgs();
              TypeLiteral _get_7 = _args_9.get(i);
              String _string_2 = _get_7.toString();
              String _plus_6 = (decl_fun_T + _string_2);
              decl_fun_T = _plus_6;
              boolean _equals_5 = Objects.equal(type, null);
              if (_equals_5) {
                current_T = (current_T + "?");
              } else {
                String _string_3 = type.toString();
                String _plus_7 = (current_T + _string_3);
                current_T = _plus_7;
              }
            }
          }
        }
        if (flag) {
          this.error(
            (((("Type mismatch: expected (" + decl_fun_T) + ") but was (") + current_T) + ")"), 
            Facpl2Package.Literals.DECLARED_FUNCTION__FUNCTION_ID);
        }
      }
    }
    return;
  }
  
  /**
   * ###########################################################
   * TYPE CHECKs
   * ###########################################################
   */
  @Check
  public void checkTarget(final FacplPolicy policy) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(policy);
    tCheck.doSwitch(_root);
    Expression _target = policy.getTarget();
    final FacplType type = tCheck.doSwitch(_target);
    if (((!type.equals(FacplType.BOOLEAN)) && (!type.equals(FacplType.NAME)))) {
      this.warning(
        "Target Expression evaluates to a not-boolean value. This element evaluates to indeterminate", 
        Facpl2Package.Literals.FACPL_POLICY__TARGET);
    }
  }
  
  @Check
  public void checkSet(final it.unifi.xtext.facpl.facpl2.Set Set) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(Set);
    tCheck.doSwitch(_root);
    EList<Expression> _args = Set.getArgs();
    Expression _get = _args.get(0);
    FacplType t = tCheck.doSwitch(_get);
    EList<Expression> _args_1 = Set.getArgs();
    for (final Expression ob : _args_1) {
      FacplType _doSwitch = tCheck.doSwitch(ob);
      FacplType _combine = FacplType.combine(t, _doSwitch);
      t = _combine;
    }
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Set elements have to be of the same type", Facpl2Package.Literals.SET__ARGS);
    }
    EList<Expression> _args_2 = Set.getArgs();
    for (final Expression ob_1 : _args_2) {
      {
        if ((ob_1 instanceof it.unifi.xtext.facpl.facpl2.Set)) {
          this.error("Sets cannot contain other Sets", Facpl2Package.Literals.SET__ARGS);
        }
        if ((ob_1 instanceof AttributeName)) {
          this.error("Sets cannot contain attribute name", Facpl2Package.Literals.SET__ARGS);
        }
      }
    }
  }
  
  @Check
  public void checkFunction(final Function e) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(e);
    tCheck.doSwitch(_root);
    FacplType t = tCheck.doSwitch(e);
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Expression cannot be typed", Facpl2Package.Literals.FUNCTION__FUNCTION_ID);
    }
    funID _functionId = e.getFunctionId();
    boolean _equals_1 = _functionId.equals(funID.IN);
    if (_equals_1) {
      this.info("Function \'in\' expects (T,Set<T>)", Facpl2Package.Literals.FUNCTION__FUNCTION_ID);
    }
  }
  
  @Check
  public void checkAndExpression(final AndExpression e) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(e);
    tCheck.doSwitch(_root);
    FacplType t = tCheck.doSwitch(e);
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Expression cannot be typed", Facpl2Package.Literals.AND_EXPRESSION__LEFT);
    }
  }
  
  @Check
  public void checkOrExpression(final OrExpression e) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(e);
    tCheck.doSwitch(_root);
    FacplType t = tCheck.doSwitch(e);
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Expression cannot be typed", Facpl2Package.Literals.OR_EXPRESSION__LEFT);
    }
  }
  
  @Check
  public void checkNotExpression(final NotExpression e) {
    final FacplTypeInference tCheck = new FacplTypeInference();
    Facpl _root = this.getRoot(e);
    tCheck.doSwitch(_root);
    FacplType t = tCheck.doSwitch(e);
    boolean _equals = t.equals(FacplType.ERR);
    if (_equals) {
      this.error("Expression cannot be typed", Facpl2Package.Literals.NOT_EXPRESSION__ARG);
    }
  }
}
